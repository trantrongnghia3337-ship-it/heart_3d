<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Heart + Flying Text</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden}
    canvas{position:absolute;left:0;top:0;width:100%;height:100%}
  </style>
</head>
<body>
<canvas id="heart"></canvas>

<script>
/* ------------------ RAF polyfill ------------------ */
window.requestAnimationFrame =
  window.__requestAnimationFrame ||
  window.requestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.mozRequestAnimationFrame ||
  window.oRequestAnimationFrame ||
  window.msRequestAnimationFrame ||
  (function () {
    return function (callback, element) {
      var lastTime = element.__lastTime || 0;
      var currTime = Date.now();
      var timeToCall = Math.max(1, 33 - (currTime - lastTime));
      window.setTimeout(callback, timeToCall);
      element.__lastTime = currTime + timeToCall;
    };
  })();

/* ------------------ Setup ------------------ */
const isDevice = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i
  .test((navigator.userAgent || navigator.vendor || window.opera).toLowerCase());

let loaded = false;
let texts = []; // mảng chữ bay

function init(){
  if(loaded) return; loaded = true;

  const mobile = isDevice;
  const koef = mobile ? 0.5 : 1;
  const canvas = document.getElementById('heart');
  const ctx = canvas.getContext('2d');
  let width  = canvas.width  = koef * innerWidth;
  let height = canvas.height = koef * innerHeight;
  const rand = Math.random;

  ctx.fillStyle = "rgba(0,0,0,1)";
  ctx.fillRect(0,0,width,height);

  function heartPosition(rad){
    // công thức hình tim (x, y)
    return [
      Math.pow(Math.sin(rad), 3),
      -(15*Math.cos(rad) - 5*Math.cos(2*rad) - 2*Math.cos(3*rad) - Math.cos(4*rad))
    ];
  }
  function scaleAndTranslate(pos, sx, sy, dx, dy){
    return [dx + pos[0]*sx, dy + pos[1]*sy];
  }

  window.addEventListener('resize', function(){
    width  = canvas.width  = koef * innerWidth;
    height = canvas.height = koef * innerHeight;
    ctx.fillStyle = "rgba(0,0,0,1)";
    ctx.fillRect(0,0,width,height);
  });

  /* ---------- tạo các điểm đích hình tim ---------- */
  const traceCount = mobile ? 20 : 50;
  const pointsOrigin = [];
  let i, dr = mobile ? 0.3 : 0.1;

  for(i=0;i<Math.PI*2;i+=dr) pointsOrigin.push(scaleAndTranslate(heartPosition(i), 210, 13, 0, 0));
  for(i=0;i<Math.PI*2;i+=dr) pointsOrigin.push(scaleAndTranslate(heartPosition(i), 150, 9, 0, 0));
  for(i=0;i<Math.PI*2;i+=dr) pointsOrigin.push(scaleAndTranslate(heartPosition(i),  90, 5, 0, 0));
  const heartPointsCount = pointsOrigin.length;

  const targetPoints = [];
  function pulse(kx, ky){
    for(i=0;i<pointsOrigin.length;i++){
      targetPoints[i] = [
        kx*pointsOrigin[i][0] + width/2,
        ky*pointsOrigin[i][1] + height/2
      ];
    }
  }

  /* ---------- hạt chuyển động + vệt đuôi ---------- */
  const e = [];
  for(i=0;i<heartPointsCount;i++){
    const x = rand()*width, y = rand()*height;
    e[i] = {
      vx:0, vy:0,
      R:2,
      speed: rand()+5,
      q: ~~(rand()*heartPointsCount),
      D: 2*(i%2)-1,
      force: 0.2*rand()+0.7,
      f: "hsla(185,"+ ~~(40*rand()+60) +"%,"+ ~~(60*rand()+20) +"%,.35)",
      trace: []
    };
    for(let k=0;k<traceCount;k++) e[i].trace[k] = {x, y};
  }

  const config = { traceK:0.4, timeDelta:0.01 };
  let time = 0;

  /* ---------- chữ bay xung quanh (KHÔNG quỹ đạo cố định) ---------- */
  const messages = [
    "May mắn", "Yêu thương", "Xinh đẹp", "Rạng rỡ", "Hạnh phúc", "Tỏa sáng"
  ];
  // tạo đối tượng chữ với vị trí/ vận tốc ngẫu nhiên
  for(const m of messages){
    texts.push({
      text: m,
      x: width/2  + (rand()-0.5)*300,
      y: height/2 + (rand()-0.5)*160,
      vx: (rand()-0.5)*1.2,
      vy: (rand()-0.5)*0.8,
      size: mobile ? 16 : 22,
      hue: 185 + (rand()*20-10),          // xanh cyan biến thiên nhẹ
      jitter: rand()*Math.PI*2,           // pha rung
      wobble: 8 + rand()*10               // biên độ rung
    });
  }

  function drawFlyingTexts(t){
    ctx.save();
    ctx.globalCompositeOperation = 'screen'; // phát sáng
    for(const s of texts){
      // cập nhật chuyển động tự do + rung nhẹ
      s.x += s.vx + Math.sin(t*0.02 + s.jitter)*0.2;
      s.y += s.vy + Math.cos(t*0.018 + s.jitter)*0.2;

      // “bật tường” trong khung an toàn quanh tim
      const padX = 60, padY = 40;
      if(s.x < padX || s.x > width-padX)  s.vx *= -1;
      if(s.y < padY || s.y > height-padY) s.vy *= -1;

      ctx.font = `bold ${s.size}px "Segoe UI", Roboto, Arial, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const color = `hsl(${s.hue}, 100%, 70%)`;
      ctx.shadowColor = color;
      ctx.shadowBlur = 6;
      ctx.fillStyle = `hsla(${s.hue}, 100%, 75%, 0.8)`;

      // xoay rất nhẹ để chữ không “đứng yên”
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(Math.sin(t*0.01 + s.jitter) * 0.08);
      ctx.fillText(s.text, 0, 0);
      ctx.restore();
    }
    ctx.restore();
  }

  /* ---------- vòng lặp vẽ ---------- */
  function loop(){
    // nhịp tim (phồng - xẹp)
    const n = -Math.cos(time);
    pulse((1+n)*.5, (1+n)*.5);
    time += ((Math.sin(time)) < 0 ? 9 : (n > 0.8) ? .2 : 1) * config.timeDelta;

    // phủ lớp mờ để tạo “afterimage” (vệt sáng)
    ctx.fillStyle = "rgba(0,0,0,.10)";
    ctx.fillRect(0,0,width,height);

    // cập nhật & vẽ các hạt tim
    for(let i=e.length; i--;){
      const u = e[i], q = targetPoints[u.q];
      let dx = u.trace[0].x - q[0];
      let dy = u.trace[0].y - q[1];
      let L  = Math.sqrt(dx*dx + dy*dy) || 1;

      if(L < 10){
        if(Math.random() > 0.95) u.q = ~~(Math.random()*heartPointsCount);
        else{
          if(Math.random() > 0.99) u.D *= -1;
          u.q += u.D; u.q %= heartPointsCount; if(u.q < 0) u.q += heartPointsCount;
        }
      }
      u.vx += -dx/L * u.speed;
      u.vy += -dy/L * u.speed;
      u.trace[0].x += u.vx;
      u.trace[0].y += u.vy;
      u.vx *= u.force; u.vy *= u.force;

      for(let k=0; k<u.trace.length-1;){
        const T = u.trace[k], N = u.trace[++k];
        N.x -= config.traceK * (N.x - T.x);
        N.y -= config.traceK * (N.y - T.y);
      }

      ctx.fillStyle = u.f;
      for(let k=0;k<u.trace.length;k++){
        ctx.fillRect(u.trace[k].x, u.trace[k].y, 1.5, 1.5);
      }
    }

    // vẽ chữ bay quanh (sau cùng để nổi trên hạt)
    drawFlyingTexts(time);

    requestAnimationFrame(loop, canvas);
  }

  loop();
}

/* ---------- boot ---------- */
const s = document.readyState;
if (s === 'complete' || s === 'loaded' || s === 'interactive') init();
else document.addEventListener('DOMContentLoaded', init, false);
</script>
</body>
</html>
